p {
  background-color: #bbb;
  display: inline-block;
  width: 45vw;
  font-size: 20px;
  margin: 10px;
}
@media only screen and (max-width: 600px) {
  p {
    width: 90vw;
    display: block;
  }
}
/*
nth-child(4n)   <-- ir de 4 en 4 en los hijos
nth-child(2n) == nth-child(oven)
nth-child(2n-1) == nth-child(odd)
.hola e:first-child <-- primer hijo e del elemento con la clase hola
.hola E:first-of-type <-- primer tipo de elemento E de la clase hola
.hola *:not(.primero, #tercero) <- estilizar todos lo que este en la clase hola menos el de claes primero y el de id tercero

[atributo] <- si se encuentra
[atributo='valor'] <- valor literal
[atributo~='valor'] <-  si se encuentra un valor dentro de los valores separados por espacios
[atributo|='valor'] <- un sub valor que se encuentra separado por un guion como valor-numero
[atributo*='sub-cadena'] <- si algún valor contiene esa palabra en cuanquier parte
[atributo^='antes'] <- el valor comienza por antes
[atributo$='despues'] <- el valor termina con despues

P > H { ... } <-- seleccionar los hijos directos H
P H { ... } <--   seleccionar todos los hijos H
H ~ h { .. } <--  seleccionar los hermanos h de H
H + h { ... } <-- seleccionar el hermano(h) siguiente de H

I M P O R T A N T E ( al hacer una seleccion en css hacerlo por lo menos con el padre o ancestro más cercano por ejemplo:
padre hijo { ... }          (especificidad 0, 0, 2)
.clase-padre hijo { ... }   (especificidad 0 ,1, 1)
como maximo colocar 3 elementos o clases distintos (ya que si hace muchos se vuelve un desorden y genera problemas con especificidad)
)
*/